// Generated by dts-bundle-generator v6.7.0

/// <reference types="emscripten" />
/// <reference types="node" />

export declare type FaustModuleFactory = EmscriptenModuleFactory<FaustModule>;
export interface FaustModule extends EmscriptenModule {
	ccall: typeof ccall;
	cwrap: typeof cwrap;
	UTF8ArrayToString(u8Array: number[], ptr: number, maxBytesToRead?: number): string;
	stringToUTF8Array(str: string, outU8Array: number[], outIdx: number, maxBytesToWrite: number): number;
	UTF8ToString: typeof UTF8ToString;
	UTF16ToString: typeof UTF16ToString;
	UTF32ToString: typeof UTF32ToString;
	stringToUTF8: typeof stringToUTF8;
	stringToUTF16: typeof stringToUTF16;
	stringToUTF32: typeof stringToUTF32;
	allocateUTF8: typeof allocateUTF8;
	lengthBytesUTF8: typeof lengthBytesUTF8;
	lengthBytesUTF16: typeof lengthBytesUTF16;
	lengthBytesUTF32: typeof lengthBytesUTF32;
	FS: typeof FS;
	libFaustWasm: new () => LibFaustWasm;
}
export declare type FaustInfoType = "help" | "version" | "libdir" | "includedir" | "archdir" | "dspdir" | "pathslist";
export interface IntVector {
	size(): number;
	get(i: number): number;
	delete(): void;
}
export interface FaustDspWasm {
	cfactory: number;
	data: IntVector;
	json: string;
}
export interface LibFaustWasm {
	/**
	 * Return the Faust compiler version.
	 *
	 * @returns the version
	 */
	version(): string;
	/**
	 * Create a dsp factory from Faust code.
	 *
	 * @param name - an arbitrary name for the Faust module
	 * @param code - Faust dsp code
	 * @param args - the compiler options
	 * @param useInternalMemory - tell the compiler to generate static embedded memory or not
	 * @returns an opaque reference to the factory
	 */
	createDSPFactory(name: string, code: string, args: string, useInternalMemory: boolean): FaustDspWasm;
	/**
	 * Delete a dsp factory.
	 *
	 * @param cFactory - the factory C++ internal pointer as a number
	 */
	deleteDSPFactory(cFactory: number): void;
	/**
	 * Expand Faust code i.e. linearize included libraries.
	 *
	 * @param name - an arbitrary name for the Faust module
	 * @param code - Faust dsp code
	 * @param args - the compiler options
	 * @returns return the expanded dsp code
	 */
	expandDSP(name: string, code: string, args: string): string;
	/**
	 * Generates auxiliary files from Faust code. The output depends on the compiler options.
	 *
	 * @param name - an arbitrary name for the faust module
	 * @param code - Faust dsp code
	 * @param args - the compiler options
	 */
	generateAuxFiles(name: string, code: string, args: string): boolean;
	/**
	 * Delete all existing dsp factories.
	 */
	deleteAllDSPFactories(): void;
	/**
	 * Exception management: gives an error string
	 */
	getErrorAfterException(): string;
	/**
	 * Exception management: cleanup
	 * Should be called after each exception generated by the LibFaust methods.
	 */
	cleanupAfterException(): void;
	/**
	 * Get info about the embedded Faust engine
	 * @param what - the requested info
	 */
	getInfos(what: FaustInfoType): string;
}
/**
 * The Factory structure.
 * cfactory: a "pointer" (as an integer) on the internal C++ factory
 * code: the WASM code as a binary array
 * module: the compule WASM module
 * json: the compiled DSP JSON description
 * poly: whether the factory is a polyphonic one or not
 */
export interface FaustDspFactory extends Required<LooseFaustDspFactory> {
}
export interface LooseFaustDspFactory {
	cfactory?: number;
	code?: Uint8Array;
	module: WebAssembly.Module;
	json: string;
	poly?: boolean;
	shaKey?: string;
}
export interface FaustDspMeta {
	name: string;
	filename: string;
	compile_options: string;
	include_pathnames: string[];
	inputs: number;
	outputs: number;
	size: number;
	version: string;
	library_list: string[];
	meta: {
		[key: string]: string;
	}[];
	ui: FaustUIDescriptor;
}
export declare type FaustUIDescriptor = FaustUIGroup[];
export declare type FaustUIItem = FaustUIInputItem | FaustUIOutputItem | FaustUIGroup;
export interface FaustUIInputItem {
	type: FaustUIInputType;
	label: string;
	address: string;
	index: number;
	init?: number;
	min?: number;
	max?: number;
	step?: number;
	meta?: FaustUIMeta[];
}
export interface FaustUIOutputItem {
	type: FaustUIOutputType;
	label: string;
	address: string;
	index: number;
	min?: number;
	max?: number;
	meta?: FaustUIMeta[];
}
export interface FaustUIMeta {
	[order: number]: string;
	style?: string;
	unit?: string;
	scale?: "linear" | "exp" | "log";
	tooltip?: string;
	hidden?: string;
	[key: string]: string | undefined;
}
export declare type FaustUIGroupType = "vgroup" | "hgroup" | "tgroup";
export declare type FaustUIOutputType = "hbargraph" | "vbargraph";
export declare type FaustUIInputType = "vslider" | "hslider" | "button" | "checkbox" | "nentry";
export interface FaustUIGroup {
	type: FaustUIGroupType;
	label: string;
	items: FaustUIItem[];
}
export declare type FaustUIType = FaustUIGroupType | FaustUIOutputType | FaustUIInputType;
export interface AudioParamDescriptor {
	automationRate?: AutomationRate;
	defaultValue?: number;
	maxValue?: number;
	minValue?: number;
	name: string;
}
export interface AudioWorkletProcessor {
	port: MessagePort;
	process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>): boolean;
}
export declare const AudioWorkletProcessor: {
	prototype: AudioWorkletProcessor;
	parameterDescriptors: AudioParamDescriptor[];
	new (options: AudioWorkletNodeOptions): AudioWorkletProcessor;
};
export interface AudioWorkletGlobalScope {
	AudioWorkletGlobalScope: any;
	globalThis: AudioWorkletGlobalScope;
	registerProcessor: (name: string, constructor: new (options: any) => AudioWorkletProcessor) => void;
	currentFrame: number;
	currentTime: number;
	sampleRate: number;
	AudioWorkletProcessor: typeof AudioWorkletProcessor;
}
/**
 * Load libfaust-wasm files, than instantiate libFaust
 * @param jsFile path to `libfaust-wasm.js`
 * @param dataFile path to `libfaust-wasm.data`
 * @param wasmFile path to `libfaust-wasm.wasm`
 */
export declare const instantiateFaustModuleFromFile: (jsFile: string, dataFile?: string, wasmFile?: string) => Promise<FaustModule>;
/**
 * The Faust wasm instance interface.
 */
export interface IFaustDspInstance {
	/**
	 * The dsp computation, to be called with successive input/output audio buffers.
	 *
	 * @param $dsp - the DSP pointer
	 * @param count - the audio buffer size in frames
	 * @param $inputs - the input audio buffer as in index in wasm memory
	 * @param $output - the output audio buffer as in index in wasm memory
	 */
	compute($dsp: number, count: number, $inputs: number, $output: number): void;
	/**
	 * Give the number of inputs of a Faust wasm instance.
	 *
	 * @param $dsp - the DSP pointer
	 */
	getNumInputs($dsp: number): number;
	/**
	 * Give the number of outputs of a Faust wasm instance.
	 *
	 * @param $dsp - the DSP pointer
	 */
	getNumOutputs($dsp: number): number;
	/**
	 * Give a parameter current value.
	 *
	 * @param $dsp - the DSP pointer
	 * @param index - the parameter index
	 * @preturn the parameter value
	 */
	getParamValue($dsp: number, index: number): number;
	/**
	 * Give the Faust wasm instance sample rate.
	 *
	 * @param $dsp - the DSP pointer
	 * @preturn the sample rate
	 */
	getSampleRate($dsp: number): number;
	/**
	 * Global init, calls the following methods:
	 * - static class 'classInit': static tables initialization
	 * - 'instanceInit': constants and instance state initialization
	 *
	 * @param $dsp - the DSP pointer
	 * @param sampleRate - the sampling rate in Hertz
	 */
	init($dsp: number, sampleRate: number): void;
	/** Init instance state (delay lines...).
	 *
	 * @param $dsp - the DSP pointer
	 */
	instanceClear($dsp: number): void;
	/** Init instance constant state.
	 *
	 * @param $dsp - the DSP pointer
	 * @param sampleRate - the sampling rate in Hertz
	 */
	instanceConstants($dsp: number, sampleRate: number): void;
	/** Init instance state.
	 *
	 * @param $dsp - the DSP pointer
	 * @param sampleRate - the sampling rate in Hertz
	 */
	instanceInit($dsp: number, sampleRate: number): void;
	/** Init default control parameters values.
	 *
	 * @param $dsp - the DSP pointer
	 */
	instanceResetUserInterface($dsp: number): void;
	/**
	 * Set a parameter current value.
	 *
	 * @param $dsp - the DSP pointer
	 * @param index - the parameter index
	 * @param value - the parameter value
	 */
	setParamValue($dsp: number, index: number, value: number): void;
}
/**
 * Mixer used in polyphonic mode.
 */
export interface IFaustMixerInstance {
	clearOutput(bufferSize: number, chans: number, $outputs: number): void;
	mixCheckVoice(bufferSize: number, chans: number, $inputs: number, $outputs: number): number;
	fadeOut(bufferSize: number, chans: number, $outputs: number): void;
}
/**
 * Monophonic instance.
 */
export interface FaustMonoDspInstance {
	memory: WebAssembly.Memory;
	api: IFaustDspInstance;
	json: string;
}
/**
 * Polyphonic instance.
 */
export interface FaustPolyDspInstance {
	memory: WebAssembly.Memory;
	voices: number;
	voiceAPI: IFaustDspInstance;
	effectAPI?: IFaustDspInstance;
	mixerAPI: IFaustMixerInstance;
	voiceJSON: string;
	effectJSON?: string;
}
export declare class FaustDspInstance implements IFaustDspInstance {
	private readonly fExports;
	constructor(exports: IFaustDspInstance);
	compute($dsp: number, count: number, $input: number, $output: number): void;
	getNumInputs($dsp: number): number;
	getNumOutputs($dsp: number): number;
	getParamValue($dsp: number, index: number): number;
	getSampleRate($dsp: number): number;
	init($dsp: number, sampleRate: number): void;
	instanceClear($dsp: number): void;
	instanceConstants($dsp: number, sampleRate: number): void;
	instanceInit($dsp: number, sampleRate: number): void;
	instanceResetUserInterface($dsp: number): void;
	setParamValue($dsp: number, index: number, value: number): void;
}
export declare class FaustWasmInstantiator {
	private static createWasmImport;
	private static createWasmMemory;
	private static createMonoDSPInstanceAux;
	private static createMemoryAux;
	private static createMixerAux;
	static loadDSPFactory(wasmPath: string, jsonPath: string): Promise<FaustDspFactory | null>;
	static loadDSPMixer(mixerPath: string, fs?: typeof FS): Promise<WebAssembly.Module | null>;
	static createAsyncMonoDSPInstance(factory: LooseFaustDspFactory): Promise<FaustMonoDspInstance>;
	static createSyncMonoDSPInstance(factory: LooseFaustDspFactory): FaustMonoDspInstance;
	static createAsyncPolyDSPInstance(voiceFactory: LooseFaustDspFactory, mixerModule: WebAssembly.Module, voices: number, effectFactory?: LooseFaustDspFactory): Promise<FaustPolyDspInstance>;
	static createSyncPolyDSPInstance(voiceFactory: LooseFaustDspFactory, mixerModule: WebAssembly.Module, voices: number, effectFactory?: LooseFaustDspFactory): FaustPolyDspInstance;
}
export declare type OutputParamHandler = (path: string, value: number) => void;
export declare type ComputeHandler = (buffer_size: number) => void;
export declare type PlotHandler = (plotted: Float32Array[], index: number, events?: {
	type: string;
	data: any;
}[]) => void;
export declare type MetadataHandler = (key: string, value: string) => void;
export declare type UIHandler = (item: FaustUIItem) => void;
/**
 * DSP implementation: mimic the C++ 'dsp' class:
 * - adding MIDI control: metadata are decoded and incoming MIDI messages will control the associated controllers
 * - an output handler can be set to treat produced output controllers (like 'bargraph')
 * - regular controllers are handled using setParamValue/getParamValue
 */
export interface IFaustBaseWebAudioDsp {
	/**
	 * Set the parameter output handler, to  be called in the 'compute' method with output parameters (like bargraph).
	 *
	 * @param handler - the output handler
	 */
	setOutputParamHandler(handler: OutputParamHandler | null): void;
	/**
	 * Get the parameter output handler.
	 *
	 * @return the current output handler
	 */
	getOutputParamHandler(): OutputParamHandler | null;
	/**
	 * Set the compute handler, to  be called in the 'compute' method with buffer size.
	 *
	 * @param handler - the compute handler
	 */
	setComputeHandler(handler: ComputeHandler | null): void;
	/**
	 * Get the compute handler.
	 *
	 * @return the current output handler
	 */
	getComputeHandler(): ComputeHandler | null;
	/**
	 * Set the plot handler, to  be called in the 'compute' method with various info (see PlotHandler type).
	 *
	 * @param handler - the plot handler
	 */
	setPlotHandler(handler: PlotHandler | null): void;
	/**
	 * Get the plot handler.
	 *
	 * @return the current plot handler
	 */
	getPlotHandler(): PlotHandler | null;
	/**
	 * Return instance number of audio inputs.
	 *
	 * @return the instance number of audio inputs
	 */
	getNumInputs(): number;
	/**
	 * Return instance number of audio outputs.
	 *
	 * @return the instance number of audio outputs
	 */
	getNumOutputs(): number;
	/**
	 * DSP instance computation, to be called with successive input/output audio buffers, using their size.
	 *
	 * @param inputs - the input audio buffers
	 * @param outputs - the output audio buffers
	 */
	compute(inputs: Float32Array[], outputs: Float32Array[]): boolean;
	/**
	 * Give a handler to be called on 'declare key value' kind of metadata.
	 *
	 * @param handler - the handler to be used
	 */
	metadata(handler: MetadataHandler): void;
	/**
	 * Handle untyped MIDI messages.
	 *
	 * @param data - and arry of MIDI bytes
	 */
	midiMessage(data: number[] | Uint8Array): void;
	/**
	 * Handle MIDI ctrlChange messages.
	 *
	 * @param channel - the MIDI channel (0..15, not used for now)
	 * @param ctrl - the MIDI controller number (0..127)
	 * @param value - the MIDI controller value (0..127)
	 */
	ctrlChange(chan: number, ctrl: number, value: number): void;
	/**
	 * Handle MIDI pitchWheel messages.
	 *
	 * @param channel - the MIDI channel (0..15, not used for now)
	 * @param value - the MIDI controller value (0..16383)
	 */
	pitchWheel(chan: number, value: number): void;
	/**
	 * Set parameter value.
	 *
	 * @param path - the path to the wanted parameter (retrieved using 'getParams' method)
	 * @param val - the float value for the wanted control
	 */
	setParamValue(path: string, value: number): void;
	/**
	 * Get parameter value.
	 *
	 * @param path - the path to the wanted parameter (retrieved using 'getParams' method)
	 *
	 * @return the float value
	 */
	getParamValue(path: string): number;
	/**
	 * Get the table of all input parameters paths.
	 *
	 * @return the table of all input parameters paths
	 */
	getParams(): string[];
	/**
	 * Get DSP JSON description with its UI and metadata as object.
	 *
	 * @return the DSP JSON description as object
	 */
	getMeta(): FaustDspMeta;
	/**
	 * Get DSP JSON description with its UI and metadata.
	 *
	 * @return the DSP JSON description
	 */
	getJSON(): string;
	/**
	 * Get DSP UI description.
	 *
	 * @return the DSP UI description
	 */
	getUI(): FaustUIDescriptor;
	/**
	* Get DSP UI items description.
	*
	* @return the DSP UI items description
	*/
	getDescriptors(): FaustUIInputItem[];
	/**
	 * Start the DSP.
	 */
	start(): void;
	/**
	 * Stop the DSP.
	 */
	stop(): void;
	/**
	 * Destroy the DSP.
	 */
	destroy(): void;
}
export interface IFaustMonoWebAudioDsp extends IFaustBaseWebAudioDsp {
}
export interface IFaustMonoWebAudioNode extends IFaustMonoWebAudioDsp, AudioNode {
}
export interface IFaustPolyWebAudioDsp extends IFaustBaseWebAudioDsp {
	/**
	 * Handle MIDI keyOn messages.
	 *
	 * @param channel - the MIDI channel (0..15, not used for now)
	 * @param pitch - the MIDI pitch value (0..127)
	 * @param velocity - the MIDI velocity value (0..127)
	 */
	keyOn(channel: number, pitch: number, velocity: number): void;
	/**
	 * Handle MIDI keyOff messages.
	 *
	 * @param channel - the MIDI channel (0..15, not used for now)
	 * @param pitch - the MIDI pitch value (0..127)
	 * @param velocity - the MIDI velocity value (0..127)
	 */
	keyOff(channel: number, pitch: number, velocity: number): void;
	/**
	 * Stop all playing notes.
	 *
	 * @param hard - whether to immediately stop notes or put them in release mode
	 */
	allNotesOff(hard: boolean): void;
}
export interface IFaustPolyWebAudioNode extends IFaustPolyWebAudioDsp, AudioNode {
}
export declare class FaustBaseWebAudioDsp implements IFaustBaseWebAudioDsp {
	protected fOutputHandler: OutputParamHandler | null;
	protected fComputeHandler: ComputeHandler | null;
	protected fPlotHandler: PlotHandler | null;
	protected fCachedEvents: {
		type: string;
		data: any;
	}[];
	protected fBufferNum: number;
	protected fInChannels: Float32Array[] | Float64Array[];
	protected fOutChannels: Float32Array[] | Float64Array[];
	protected fOutputsTimer: number;
	protected fInputsItems: string[];
	protected fOutputsItems: string[];
	protected fDescriptor: FaustUIInputItem[];
	protected fAudioInputs: number;
	protected fAudioOutputs: number;
	protected fBufferSize: number;
	protected gPtrSize: number;
	protected gSampleSize: number;
	protected fPitchwheelLabel: {
		path: string;
		min: number;
		max: number;
	}[];
	protected fCtrlLabel: {
		path: string;
		min: number;
		max: number;
	}[][];
	protected fPathTable: {
		[address: string]: number;
	};
	protected fUICallback: UIHandler;
	protected fProcessing: boolean;
	protected fDestroyed: boolean;
	protected fJSONDsp: FaustDspMeta;
	constructor(sampleSize: number, bufferSize: number);
	static remap(v: number, mn0: number, mx0: number, mn1: number, mx1: number): number;
	static parseUI(ui: FaustUIDescriptor, callback: (...args: any[]) => any): void;
	static parseGroup(group: FaustUIGroup, callback: (...args: any[]) => any): void;
	static parseItems(items: FaustUIItem[], callback: (...args: any[]) => any): void;
	static parseItem(item: FaustUIItem, callback: (...args: any[]) => any): void;
	protected updateOutputs(): void;
	metadata(handler: MetadataHandler): void;
	compute(input: Float32Array[], output: Float32Array[]): boolean;
	setOutputParamHandler(handler: OutputParamHandler | null): void;
	getOutputParamHandler(): OutputParamHandler | null;
	setComputeHandler(handler: ComputeHandler | null): void;
	getComputeHandler(): ComputeHandler | null;
	setPlotHandler(handler: PlotHandler | null): void;
	getPlotHandler(): PlotHandler | null;
	getNumInputs(): number;
	getNumOutputs(): number;
	midiMessage(data: number[] | Uint8Array): void;
	ctrlChange(channel: number, ctrl: number, value: number): void;
	pitchWheel(channel: number, wheel: number): void;
	setParamValue(path: string, value: number): void;
	getParamValue(path: string): number;
	getParams(): string[];
	getMeta(): FaustDspMeta;
	getJSON(): string;
	getUI(): FaustUIDescriptor;
	getDescriptors(): FaustUIInputItem[];
	start(): void;
	stop(): void;
	destroy(): void;
}
export declare class FaustMonoWebAudioDsp extends FaustBaseWebAudioDsp implements IFaustMonoWebAudioDsp {
	private fInstance;
	private fDSP;
	constructor(instance: FaustMonoDspInstance, sampleRate: number, sampleSize: number, bufferSize: number);
	private initMemory;
	toString(): string;
	compute(input: Float32Array[], output: Float32Array[]): boolean;
	metadata(handler: MetadataHandler): void;
	getNumInputs(): number;
	getNumOutputs(): number;
	setParamValue(path: string, value: number): void;
	getParamValue(path: string): number;
	getMeta(): FaustDspMeta;
	getJSON(): string;
	getDescriptors(): FaustUIInputItem[];
	getUI(): FaustUIDescriptor;
}
export declare class FaustWebAudioDspVoice {
	static kActiveVoice: number;
	static kFreeVoice: number;
	static kReleaseVoice: number;
	static kLegatoVoice: number;
	static kNoVoice: number;
	static VOICE_STOP_LEVEL: number;
	private fFreqLabel;
	private fGateLabel;
	private fGainLabel;
	private fKeyLabel;
	private fVelLabel;
	private fDSP;
	private fAPI;
	fCurNote: number;
	fNextNote: number;
	fNextVel: number;
	fDate: number;
	fLevel: number;
	fRelease: number;
	constructor($dsp: number, api: IFaustDspInstance, inputItems: string[], pathTable: {
		[address: string]: number;
	}, sampleRate: number);
	static midiToFreq(note: number): number;
	static normalizeVelocity(velocity: number): number;
	private extractPaths;
	keyOn(pitch: number, velocity: number, legato?: boolean): void;
	keyOff(hard?: boolean): void;
	computeLegato(bufferSize: number, $inputs: number, $outputZero: number, $outputsHalf: number): void;
	compute(bufferSize: number, $inputs: number, $outputs: number): void;
	setParamValue(index: number, value: number): void;
	getParamValue(index: number): number;
}
export declare class FaustPolyWebAudioDsp extends FaustBaseWebAudioDsp implements IFaustPolyWebAudioDsp {
	private fInstance;
	private fEffect;
	private fJSONEffect;
	private fAudioMixing;
	private fAudioMixingHalf;
	private fVoiceTable;
	constructor(instance: FaustPolyDspInstance, sampleRate: number, sampleSize: number, bufferSize: number);
	private initMemory;
	toString(): string;
	private allocVoice;
	private getPlayingVoice;
	private getFreeVoice;
	compute(input: Float32Array[], output: Float32Array[]): boolean;
	getNumInputs(): number;
	getNumOutputs(): number;
	private static findPath;
	setParamValue(path: string, value: number): void;
	getParamValue(path: string): number;
	getMeta(): FaustDspMeta;
	getJSON(): string;
	getUI(): FaustUIDescriptor;
	getDescriptors(): FaustUIInputItem[];
	midiMessage(data: number[] | Uint8Array): void;
	ctrlChange(channel: number, ctrl: number, value: number): void;
	keyOn(channel: number, pitch: number, velocity: number): void;
	keyOff(channel: number, pitch: number, velocity: number): void;
	allNotesOff(hard?: boolean): void;
}
/**
 * Injected in the string to be compiled on AudioWorkletProcessor side
 */
export interface FaustData {
	processorName: string;
	dspName: string;
	dspMeta: FaustDspMeta;
	poly: boolean;
	effectMeta?: FaustDspMeta;
}
export interface FaustAudioWorkletProcessorDependencies<Poly extends boolean = false> {
	FaustBaseWebAudioDsp: typeof FaustBaseWebAudioDsp;
	FaustMonoWebAudioDsp: Poly extends true ? undefined : typeof FaustMonoWebAudioDsp;
	FaustPolyWebAudioDsp: Poly extends true ? typeof FaustPolyWebAudioDsp : undefined;
	FaustWebAudioDspVoice: Poly extends true ? typeof FaustWebAudioDspVoice : undefined;
	FaustWasmInstantiator: typeof FaustWasmInstantiator;
}
export interface FaustAudioWorkletNodeOptions<Poly extends boolean = false> extends AudioWorkletNodeOptions {
	processorOptions: Poly extends true ? FaustPolyAudioWorkletProcessorOptions : FaustMonoAudioWorkletProcessorOptions;
}
export interface FaustMonoAudioWorkletNodeOptions extends AudioWorkletNodeOptions {
	processorOptions: FaustMonoAudioWorkletProcessorOptions;
}
export interface FaustPolyAudioWorkletNodeOptions extends AudioWorkletNodeOptions {
	processorOptions: FaustPolyAudioWorkletProcessorOptions;
}
export interface FaustAudioWorkletProcessorOptions {
	name: string;
	sampleSize: number;
}
export interface FaustMonoAudioWorkletProcessorOptions extends FaustAudioWorkletProcessorOptions {
	factory: LooseFaustDspFactory;
}
export interface FaustPolyAudioWorkletProcessorOptions extends FaustAudioWorkletProcessorOptions {
	voiceFactory: LooseFaustDspFactory;
	mixerModule: WebAssembly.Module;
	voices: number;
	effectFactory?: LooseFaustDspFactory;
}
export declare const getFaustAudioWorkletProcessor: <Poly extends boolean = false>(dependencies: FaustAudioWorkletProcessorDependencies<Poly>, faustData: FaustData, register?: boolean) => {
	new (options: AudioWorkletNodeOptions): AudioWorkletProcessor;
	prototype: AudioWorkletProcessor;
	parameterDescriptors: AudioParamDescriptor[];
};
export interface ILibFaust extends LibFaustWasm {
	module(): FaustModule;
	fs(): typeof FS;
}
export declare class LibFaust implements ILibFaust {
	private fModule;
	private fCompiler;
	private fFileSystem;
	constructor(module: FaustModule);
	module(): FaustModule;
	fs(): typeof FS;
	version(): string;
	createDSPFactory(name: string, code: string, args: string, useInternalMemory: boolean): FaustDspWasm;
	deleteDSPFactory(cFactory: number): void;
	expandDSP(name: string, code: string, args: string): string;
	generateAuxFiles(name: string, code: string, args: string): boolean;
	deleteAllDSPFactories(): void;
	getErrorAfterException(): string;
	cleanupAfterException(): void;
	getInfos(what: FaustInfoType): string;
	toString(): string;
}
export declare const ab2str: (buf: Uint8Array) => any;
export declare const str2ab: (str: string) => Uint8Array;
export interface IFaustCompiler {
	/**
	 * Gives the Faust compiler version.
	 * @return a version string
	 */
	version(): string;
	/**
	 * Gives the last compilation error.
	 * @return an error string
	 */
	getErrorMessage(): string;
	/**
	 * Create a wasm factory from Faust code i.e. wasm compiled code, to be used to create monophonic instances.
	 * This function is running asynchronously.
	 *
	 * @param name - an arbitrary name for the Faust factory
	 * @param code - Faust dsp code
	 * @param args - the compiler options
	 * @returns returns the wasm factory
	 */
	createMonoDSPFactory(name: string, code: string, args: string): Promise<FaustDspFactory | null>;
	/**
	 * Create a wasm factory from Faust code i.e. wasm compiled code, to be used to create polyphonic instances.
	 * This function is running asynchronously.
	 *
	 * @param name - an arbitrary name for the Faust factory
	 * @param code - Faust dsp code
	 * @param args - the compiler options
	 * @returns returns the wasm factory
	 */
	createPolyDSPFactory(name: string, code: string, args: string): Promise<FaustDspFactory | null>;
	/**
	 * Delete a dsp factory.
	 *
	 * @param factory - the factory to be deleted
	 */
	deleteDSPFactory(factory: FaustDspFactory): void;
	/**
	 * Expand Faust code i.e. linearize included libraries.
	 *
	 * @param code - Faust dsp code
	 * @param args - the compiler options
	 * @returns returns the expanded dsp code
	 */
	expandDSP(code: string, args: string): string | null;
	/**
	 * Generates auxiliary files from Faust code. The output depends on the compiler options.
	 *
	 * @param name - an arbitrary name for the Faust module
	 * @param code - Faust dsp code
	 * @param args - the compiler options
	 * @returns whether the generation actually succeded
	 */
	generateAuxFiles(name: string, code: string, args: string): boolean;
	/**
	 * Delete all factories.
	 */
	deleteAllDSPFactories(): void;
	fs(): typeof FS;
	getAsyncInternalMixerModule(isDouble?: boolean): Promise<{
		mixerBuffer: Uint8Array;
		mixerModule: WebAssembly.Module;
	}>;
	getSyncInternalMixerModule(isDouble?: boolean): {
		mixerBuffer: Uint8Array;
		mixerModule: WebAssembly.Module;
	};
}
export declare class FaustCompiler implements IFaustCompiler {
	private fLibFaust;
	private fErrorMessage;
	private static gFactories;
	private mixer32Buffer;
	private mixer64Buffer;
	private mixer32Module;
	private mixer64Module;
	/**
	 * Get a stringified DSP factories table
	 */
	static stringifyDSPFactories(): string;
	/**
	 * Import a stringified DSP factories table
	 */
	static importDSPFactories(tableStr: string): Promise<Map<string, FaustDspFactory>[]>;
	constructor(libFaust: ILibFaust);
	private intVec2intArray;
	private createDSPFactory;
	version(): string;
	getErrorMessage(): string;
	createMonoDSPFactory(name: string, code: string, args: string): Promise<FaustDspFactory | null>;
	createPolyDSPFactory(name: string, code: string, args: string): Promise<FaustDspFactory | null>;
	deleteDSPFactory(factory: FaustDspFactory): void;
	expandDSP(code: string, args: string): string | null;
	generateAuxFiles(name: string, code: string, args: string): boolean;
	deleteAllDSPFactories(): void;
	fs(): typeof FS;
	getAsyncInternalMixerModule(isDouble?: boolean): Promise<{
		mixerBuffer: Uint8Array;
		mixerModule: WebAssembly.Module;
	}>;
	getSyncInternalMixerModule(isDouble?: boolean): {
		mixerBuffer: Uint8Array;
		mixerModule: WebAssembly.Module;
	};
}
/**
 *  For offline rendering.
 */
export interface IFaustOfflineProcessor {
	/**
	 * Render frames in an array.
	 *
	 * @param inputs - input signal
	 * @param length - the number of frames to render (default: bufferSize)
	 * @param onUpdate - a callback after each buffer calculated, with an argument "current sample"
	 * @return an array of Float32Array with the rendered frames
	 */
	render(inputs?: Float32Array[], length?: number, onUpdate?: (sample: number) => any): Float32Array[];
}
export declare class FaustOfflineProcessor implements IFaustOfflineProcessor {
	private fDSPCode;
	private fBufferSize;
	private fInputs;
	private fOutputs;
	constructor(instance: IFaustMonoWebAudioDsp, bufferSize: number);
	render(inputs?: Float32Array[], length?: number, onUpdate?: (sample: number) => any): Float32Array[];
}
export interface IFaustSvgDiagrams {
	/**
	 * Generates auxiliary files from Faust code. The output depends on the compiler options.
	 *
	 * @param name - the DSP's name
	 * @param code - Faust code
	 * @param args - compilation args
	 * @returns the svg diagrams as a filename - svg string map
	 */
	from(name: string, code: string, args: string): Record<string, string>;
}
export declare class FaustSvgDiagrams implements IFaustSvgDiagrams {
	private compiler;
	constructor(compiler: FaustCompiler);
	from(name: string, code: string, args: string): Record<string, string>;
}
export interface WavEncoderOptions {
	bitDepth: number;
	float?: boolean;
	symmetric?: boolean;
	shared?: boolean;
	sampleRate: number;
}
/**
 * Code from https://github.com/mohayonao/wav-encoder
 */
export declare class WavEncoder {
	static encode(audioBuffer: Float32Array[], options: WavEncoderOptions): ArrayBuffer;
	private static writeHeader;
	private static writeData;
}
export interface WavDecoderOptions {
	symmetric?: boolean;
	shared?: boolean;
}
/**
 * Code from https://github.com/mohayonao/wav-decoder
 */
export declare class WavDecoder {
	static decode(buffer: ArrayBuffer, options?: WavDecoderOptions): {
		numberOfChannels: number;
		length: number;
		sampleRate: number;
		channelData: Float32Array[];
	};
	private static decodeFormat;
	private static decodeData;
	private static readPCM;
}
declare const FaustAudioWorkletNode_base: {
	new (context: BaseAudioContext, name: string, options?: AudioWorkletNodeOptions | undefined): AudioWorkletNode;
	prototype: AudioWorkletNode;
};
/**
 * Base class for Monophonic and Polyphonic AudioWorkletNode
 */
export declare class FaustAudioWorkletNode<Poly extends boolean = false> extends FaustAudioWorkletNode_base {
	protected fJSONDsp: FaustDspMeta;
	protected fJSON: string;
	protected fInputsItems: string[];
	protected fOutputHandler: OutputParamHandler | null;
	protected fComputeHandler: ComputeHandler | null;
	protected fPlotHandler: PlotHandler | null;
	protected fUICallback: UIHandler;
	protected fDescriptor: FaustUIInputItem[];
	constructor(context: BaseAudioContext, name: string, factory: LooseFaustDspFactory, options: FaustAudioWorkletNodeOptions<Poly>["processorOptions"]);
	setOutputParamHandler(handler: OutputParamHandler | null): void;
	getOutputParamHandler(): OutputParamHandler | null;
	setComputeHandler(handler: ComputeHandler | null): void;
	getComputeHandler(): ComputeHandler | null;
	setPlotHandler(handler: PlotHandler | null): void;
	getPlotHandler(): PlotHandler | null;
	getNumInputs(): number;
	getNumOutputs(): number;
	compute(inputs: Float32Array[], outputs: Float32Array[]): boolean;
	metadata(handler: MetadataHandler): void;
	midiMessage(data: number[] | Uint8Array): void;
	ctrlChange(channel: number, ctrl: number, value: number): void;
	pitchWheel(channel: number, wheel: number): void;
	setParamValue(path: string, value: number): void;
	getParamValue(path: string): number;
	getParams(): string[];
	getMeta(): FaustDspMeta;
	getJSON(): string;
	getUI(): FaustUIDescriptor;
	getDescriptors(): FaustUIInputItem[];
	start(): void;
	stop(): void;
	destroy(): void;
}
/**
 * Monophonic AudioWorkletNode
 */
export declare class FaustMonoAudioWorkletNode extends FaustAudioWorkletNode<false> implements IFaustMonoWebAudioDsp {
	onprocessorerror: (e: Event) => never;
	constructor(context: BaseAudioContext, name: string, factory: LooseFaustDspFactory, sampleSize: number);
}
/**
 * Polyphonic AudioWorkletNode
 */
export declare class FaustPolyAudioWorkletNode extends FaustAudioWorkletNode<true> implements IFaustPolyWebAudioDsp {
	private fJSONEffect;
	onprocessorerror: (e: Event) => never;
	constructor(context: BaseAudioContext, name: string, voiceFactory: LooseFaustDspFactory, mixerModule: WebAssembly.Module, voices: number, sampleSize: number, effectFactory?: LooseFaustDspFactory);
	keyOn(channel: number, pitch: number, velocity: number): void;
	keyOff(channel: number, pitch: number, velocity: number): void;
	allNotesOff(hard: boolean): void;
	getMeta(): FaustDspMeta;
	getJSON(): string;
	getUI(): FaustUIDescriptor;
}
declare const FaustScriptProcessorNode_base: {
	new (): ScriptProcessorNode;
	prototype: ScriptProcessorNode;
};
/**
 * Base class for Monophonic and Polyphonic ScriptProcessorNode
 */
export declare class FaustScriptProcessorNode<Poly extends boolean = false> extends FaustScriptProcessorNode_base {
	protected fDSPCode: Poly extends true ? FaustPolyWebAudioDsp : FaustMonoWebAudioDsp;
	protected fInputs: Float32Array[];
	protected fOutputs: Float32Array[];
	init(instance: Poly extends true ? FaustPolyWebAudioDsp : FaustMonoWebAudioDsp): void;
	compute(input: Float32Array[], output: Float32Array[]): boolean;
	setOutputParamHandler(handler: OutputParamHandler): void;
	getOutputParamHandler(): OutputParamHandler | null;
	setComputeHandler(handler: ComputeHandler): void;
	getComputeHandler(): ComputeHandler | null;
	setPlotHandler(handler: PlotHandler): void;
	getPlotHandler(): PlotHandler | null;
	getNumInputs(): number;
	getNumOutputs(): number;
	metadata(handler: MetadataHandler): void;
	midiMessage(data: number[] | Uint8Array): void;
	ctrlChange(chan: number, ctrl: number, value: number): void;
	pitchWheel(chan: number, value: number): void;
	setParamValue(path: string, value: number): void;
	getParamValue(path: string): number;
	getParams(): string[];
	getMeta(): FaustDspMeta;
	getJSON(): string;
	getDescriptors(): FaustUIInputItem[];
	getUI(): FaustUIDescriptor;
	start(): void;
	stop(): void;
	destroy(): void;
}
export declare class FaustMonoScriptProcessorNode extends FaustScriptProcessorNode<false> implements IFaustMonoWebAudioDsp {
}
export declare class FaustPolyScriptProcessorNode extends FaustScriptProcessorNode<true> implements IFaustPolyWebAudioDsp {
	keyOn(channel: number, pitch: number, velocity: number): void;
	keyOff(channel: number, pitch: number, velocity: number): void;
	allNotesOff(hard: boolean): void;
}
export interface IFaustMonoDspGenerator {
	/**
	 * Compile a monophonic DSP factory from given code.
	 *
	 * @param compiler - the Faust compiler
	 * @param name - the DSP name
	 * @param code - the DSP code
	 * @param args - the compilation parameters
	 * @returns the compiled factory or 'null' if failure
	 */
	compile(compiler: IFaustCompiler, name: string, code: string, args: string): Promise<{
		factory: FaustDspFactory | null;
		name?: string;
		meta?: FaustDspMeta;
	} | null>;
	/**
	 * Create a monophonic WebAudio node (either ScriptProcessorNode or AudioWorkletNode).
	 *
	 * @param context - the WebAudio context
	 * @param name - AudioWorklet Processor name
	 * @param factory - default is the compiled factory
	 * @param sp - whether to compile a ScriptProcessorNode or an AudioWorkletNode
	 * @param bufferSize - the buffer size in frames to be used in ScriptProcessorNode only, since AudioWorkletNode always uses 128 frames
	 * @returns the compiled WebAudio node or 'null' if failure
	*/
	createNode(context: BaseAudioContext, name?: string, factory?: LooseFaustDspFactory, sp?: boolean, bufferSize?: number): Promise<IFaustMonoWebAudioNode | null>;
	/**
	* Create a monophonic Offline processor.
	*
	* @param sampleRate - the sample rate in Hz
	* @param bufferSize - the buffer size in frames
	* @param factory - default is the compiled factory
	* @returns the compiled processor or 'null' if failure
	*/
	createOfflineProcessor(sampleRate: number, bufferSize: number, factory?: LooseFaustDspFactory, meta?: FaustDspMeta): Promise<IFaustOfflineProcessor | null>;
}
export interface IFaustPolyDspGenerator {
	/**
	 * Compile a monophonic DSP factory from given code.
	 *
	 * @param compiler - the Faust compiler
	 * @param name - the DSP name
	 * @param dspCode - the DSP code ('dsp_code' can possibly contain an integrated effect)
	 * @param args - the compilation parameters
	 * @param effectCode - optional effect DSP code
	 * @returns the compiled factory or 'null' if failure
	 */
	compile(compiler: IFaustCompiler, name: string, dspCode: string, args: string, effectCode?: string): Promise<{
		voiceFactory: FaustDspFactory | null;
		effectFactory?: FaustDspFactory | null;
	} | null>;
	/**
	 * Create a polyphonic WebAudio node (either ScriptProcessorNode or AudioWorkletNode).
	 *
	 * @param context the WebAudio context
	 * @param voices - the number of voices
	 * @param name - AudioWorklet Processor name
	 * @param voiceFactory - the Faust factory for voices, either obtained with a compiler (createDSPFactory) or loaded from files (loadDSPFactory)
	 * @param mixerModule - the wasm Mixer module (loaded from 'mixer32.wasm' or 'mixer64.wasm' files)
	 * @param effectFactory - the Faust factory for the effect, either obtained with a compiler (createDSPFactory) or loaded from files (loadDSPFactory)
	 * @param sp - whether to compile a ScriptProcessorNode or an AudioWorkletNode
	 * @param bufferSize - the buffer size in frames to be used in ScriptProcessorNode only, since AudioWorkletNode always uses 128 frames
	 * @returns the compiled WebAudio node or 'null' if failure
	 */
	createNode(context: BaseAudioContext, voices: number, name?: string, voiceFactory?: LooseFaustDspFactory, mixerModule?: WebAssembly.Module, effectFactory?: LooseFaustDspFactory | null, sp?: boolean, bufferSize?: number): Promise<IFaustPolyWebAudioNode | null>;
}
export declare class FaustMonoDspGenerator implements IFaustMonoDspGenerator {
	private static gWorkletProcessors;
	name: string;
	factory: FaustDspFactory | null;
	constructor();
	compile(compiler: IFaustCompiler, name: string, code: string, args: string): Promise<this | null>;
	createNode<SP extends boolean = false>(context: BaseAudioContext, name?: string, factory?: LooseFaustDspFactory, sp?: SP, bufferSize?: number, processorName?: string): Promise<SP extends true ? FaustMonoScriptProcessorNode | null : FaustMonoAudioWorkletNode | null>;
	createAudioWorkletProcessor(name?: string, factory?: LooseFaustDspFactory, processorName?: string): Promise<{
		new (options: AudioWorkletNodeOptions): AudioWorkletProcessor;
		prototype: AudioWorkletProcessor;
		parameterDescriptors: AudioParamDescriptor[];
	} | null>;
	createOfflineProcessor(sampleRate: number, bufferSize: number, factory?: LooseFaustDspFactory): Promise<IFaustOfflineProcessor | null>;
}
export declare class FaustPolyDspGenerator implements IFaustPolyDspGenerator {
	private static gWorkletProcessors;
	name: string;
	voiceFactory: FaustDspFactory | null;
	effectFactory: FaustDspFactory | null;
	mixerBuffer: Uint8Array;
	mixerModule: WebAssembly.Module;
	constructor();
	compile(compiler: IFaustCompiler, name: string, dspCode: string, args: string, effectCode?: string): Promise<this | null>;
	createNode<SP extends boolean = false>(context: BaseAudioContext, voices: number, name?: string, voiceFactory?: LooseFaustDspFactory, mixerModule?: WebAssembly.Module, effectFactory?: LooseFaustDspFactory | null, sp?: SP, bufferSize?: number, processorName?: string): Promise<SP extends true ? FaustPolyScriptProcessorNode | null : FaustPolyAudioWorkletNode | null>;
	createAudioWorkletProcessor(name?: string, voiceFactory?: LooseFaustDspFactory, effectFactory?: LooseFaustDspFactory | null, processorName?: string): Promise<{
		new (options: AudioWorkletNodeOptions): AudioWorkletProcessor;
		prototype: AudioWorkletProcessor;
		parameterDescriptors: AudioParamDescriptor[];
	} | null>;
}

export {};
